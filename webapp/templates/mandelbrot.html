<!DOCTYPE html>

<!--
  Hydra - Mandelbrot Calculation Page
  Copyright (C) 2025 Connor Frank

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <https://www.gnu.org/licenses/>.
-->

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hydra - Mandelbrot Calculation</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Calibri, 'Segoe UI', sans-serif;
      background: #191E19;
      min-height: 100vh;
      color: #1A1F1A;
    }

    .top-bar {
      height: 4px;
      background: #1B5E3B;
      width: 100%;
    }

    .header {
      background: #191E19;
      padding: 48px 0 40px;
      text-align: center;
    }

    .header h1 {
      font-family: Georgia, 'Times New Roman', serif;
      font-size: 2.4rem;
      font-weight: bold;
      color: #FFFFFF;
      margin-bottom: 12px;
    }

    .header .back-link {
      color: #A0A5A0;
      text-decoration: none;
      font-size: 0.9rem;
    }

    .header .back-link:hover {
      color: #FFFFFF;
    }

    .container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 0 40px;
    }

    .main-section {
      background: #F2EDE4;
      padding: 50px 0 60px;
    }

    .controls-card {
      background: #FFFFFF;
      border-radius: 6px;
      padding: 28px 28px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      border-left: 4px solid #1B5E3B;
      margin-bottom: 30px;
    }

    .controls-card form {
      display: flex;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
    }

    .controls-card label {
      font-size: 0.95rem;
      font-weight: bold;
      color: #1A1F1A;
    }

    .controls-card input[type="number"] {
      font-family: Calibri, 'Segoe UI', sans-serif;
      font-size: 0.95rem;
      padding: 8px 12px;
      border: 1px solid #E8E3DA;
      border-radius: 4px;
      background: #FAFAFA;
      color: #1A1F1A;
      width: 120px;
    }

    .controls-card input[type="number"]:focus {
      outline: none;
      border-color: #1B5E3B;
    }

    .controls-card button {
      font-family: Calibri, 'Segoe UI', sans-serif;
      font-size: 0.95rem;
      font-weight: bold;
      padding: 8px 24px;
      background: #1B5E3B;
      color: #FFFFFF;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .controls-card button:hover {
      background: #2A7A4F;
    }

    #progress {
      font-size: 0.95rem;
      color: #6B706B;
      margin-bottom: 24px;
      min-height: 1.4em;
    }

    .canvas-wrapper {
      background: #FFFFFF;
      border-radius: 6px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
    }

    #mandelCanvas {
      display: block;
      margin: 0 auto;
      width: 100%;
    }

    .footer {
      background: #191E19;
      text-align: center;
      padding: 32px 20px;
      border-top: 1px solid #232823;
    }

    .footer p {
      color: #787D78;
      font-size: 0.85rem;
    }

    .footer a {
      color: #A0A5A0;
      text-decoration: none;
    }

    .footer a:hover {
      color: #FFFFFF;
    }

    @media (max-width: 600px) {
      .header h1 {
        font-size: 1.8rem;
      }
      .container {
        padding: 0 20px;
      }
      .controls-card form {
        flex-direction: column;
        align-items: flex-start;
      }
    }
  </style>
</head>
<body>
  <div class="top-bar"></div>

  <div class="header">
    <a href="/" class="back-link">Back to Index</a>
    <h1>Mandelbrot Calculation</h1>
  </div>

  <div class="main-section">
    <div class="container">
      <div class="controls-card">
        <form id="mandelbrotForm">
          <label for="resolution">Resolution (square):</label>
          <input type="number" id="resolution" name="resolution" min="50" value="1024">
          <button type="submit">Calculate</button>
        </form>
      </div>

      <div id="progress"></div>

      <div class="canvas-wrapper">
        <canvas id="mandelCanvas"></canvas>
      </div>
    </div>
  </div>

  <div class="footer">
    <p>
      Created by <a href="https://conjfrnk.com" target="_blank">Connor Frank</a>
      &mdash;
      <a href="https://github.com/conjfrnk/hydra" target="_blank">View on GitHub</a>
    </p>
  </div>

  <script>
    let pollWorker = new Worker("/static/heartbeatWorker.js");
  </script>

  <script>
    function formatHMS(totalSeconds) {
      totalSeconds = Math.floor(totalSeconds);
      const hh = Math.floor(totalSeconds / 3600);
      const remainder = totalSeconds % 3600;
      const mm = Math.floor(remainder / 60);
      const ss = remainder % 60;
      return `${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
    }

    let currentJobId = "";
    let startTime = 0;
    let resolution = 1024;

    const progressDiv = document.getElementById('progress');
    const canvas = document.getElementById('mandelCanvas');
    const ctx = canvas.getContext('2d');

    async function updateImagePixels(jobId) {
      if (!jobId) return;
      try {
        let resp = await fetch(`/job_history/${jobId}`);
        if (!resp.ok) {
          throw new Error(`History fetch error: ${resp.status}`);
        }
        let data = await resp.json();
        if (!data.pixels) return;

        let imageData = ctx.getImageData(0, 0, resolution, resolution);
        let buf = imageData.data;

        data.pixels.forEach(p => {
          let idx = p.index;
          let c = p.color;
          let offset = idx * 4;
          if (offset + 3 >= buf.length) return;

          let r = parseInt(c.substring(1,3), 16);
          let g = parseInt(c.substring(3,5), 16);
          let b = parseInt(c.substring(5,7), 16);
          buf[offset + 0] = r;
          buf[offset + 1] = g;
          buf[offset + 2] = b;
          buf[offset + 3] = 255;
        });

        ctx.putImageData(imageData, 0, 0);
      } catch(e) {
        console.warn("updateImagePixels exception =>", e);
      }
    }

    pollWorker.onmessage = function(e) {
      let msg = e.data;
      if (msg.type === "STATUS") {
        if (msg.jobId !== currentJobId) return;
        let sData = msg.data;

        if (sData.status === "finished") {
          let endTime = Date.now();
          let elapsedSec = (endTime - startTime)/1000;
          let hms = formatHMS(elapsedSec);
          progressDiv.textContent = `Done! Took ${hms} total.`;
          updateImagePixels(currentJobId);
          pollWorker.postMessage({ type: "STOP" });
          currentJobId = "";
        } else if (sData.status === "in-progress") {
          let pct = parseFloat(sData.percent_complete);
          let elapsedSec = (Date.now() - startTime)/1000;
          let fraction = pct / 100;
          let timeLeftStr = "";
          if (fraction > 0.01) {
            let totalSecEst = elapsedSec / fraction;
            let remainSec = totalSecEst - elapsedSec;
            timeLeftStr = ` ~${formatHMS(remainSec)} left`;
          }
          progressDiv.textContent = `In progress... ${pct.toFixed(2)}% done${timeLeftStr}`;
          updateImagePixels(currentJobId);
        } else if (sData.status === "error") {
          progressDiv.textContent = "Job encountered an error or was canceled.";
          pollWorker.postMessage({ type: "STOP" });
          currentJobId = "";
        } else {
          progressDiv.textContent = `Status: ${sData.status}`;
          pollWorker.postMessage({ type: "STOP" });
          currentJobId = "";
        }
      } else if (msg.type === "ERROR") {
        console.warn("[Worker] Poll error =>", msg.info);
      }
    };

    document.getElementById('mandelbrotForm').addEventListener('submit', async evt => {
      evt.preventDefault();
      await startMandelbrotJob();
    });

    async function startMandelbrotJob() {
      if (currentJobId) {
        try {
          await fetch("/mark_old_job", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ old_job_id: currentJobId })
          });
          pollWorker.postMessage({ type: "STOP" });
        } catch(e) {
          console.warn("Error killing old job =>", e);
        }
        currentJobId = "";
      }

      resolution = parseInt(document.getElementById('resolution').value, 10);
      canvas.width = resolution;
      canvas.height = resolution;
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, resolution, resolution);

      progressDiv.textContent = "Starting Mandelbrot...";
      let createResp = await fetch("/start_job", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          task_type: "calculate_mandelbrot",
          resolution: resolution
        })
      });

      if (!createResp.ok) {
        progressDiv.textContent = "Error starting job.";
        console.error("Error start job =>", await createResp.text());
        return;
      }
      let createData = await createResp.json();
      currentJobId = createData.job_id;
      startTime = Date.now();

      pollWorker.postMessage({ type: "START", jobId: currentJobId, intervalMs: 2000 });
    }
  </script>
</body>
</html>
